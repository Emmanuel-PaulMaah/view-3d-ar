<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>AR: grenade + wikipedia screen</title>
  <meta name="description" content="WebXR AR with three.js: place a grenade model and a draggable 'screen' showing Wikipedia content." />

  <!-- three.js + loaders -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js"></script>

  <!-- html2canvas for rasterizing fetched HTML into a canvas -->
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#000; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #ui {
      position: fixed; left: 0; right: 0; bottom: 0; padding: 8px;
      display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;
      pointer-events: none;
    }
    .pill {
      pointer-events: auto; background: rgba(0,0,0,.7); color:#fff; border:1px solid #333;
      border-radius: 999px; padding: 8px 12px; font-size: 14px;
    }
    #msg { position: fixed; top: 8px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); padding: 6px 10px; border:1px solid #333; border-radius: 8px; font-size:13px; }
    a { color:#9ad; }
    /* offscreen content container (never visible) */
    #offscreen {
      position: absolute; left: -99999px; top: -99999px; width: 640px; height: 1024px; overflow: auto; background: #fff; color:#111;
    }
    #offscreen * { max-width: 100% !important; }
    #arbtn { position: fixed; right: 8px; bottom: 8px; z-index: 3; }
  </style>
</head>
<body>
  <div id="msg">tap to place; tap an object to pick up, then move your phone to drag. use buttons to switch target & scale. wikipedia content is a rasterized snapshot (no live links).</div>

  <!-- offscreen DOM where we inject Wikipedia mobile HTML and then rasterize -->
  <div id="offscreen"></div>

  <div id="ui">
    <button class="pill" id="targetGrenade">target: grenade</button>
    <button class="pill" id="targetScreen">target: screen</button>
    <button class="pill" id="scaleDown">scale −</button>
    <button class="pill" id="scaleUp">scale +</button>
    <button class="pill" id="scrollUp">scroll ↑</button>
    <button class="pill" id="scrollDown">scroll ↓</button>
    <a class="pill" id="openLink" href="https://en.m.wikipedia.org/wiki/Augmented_reality" target="_blank" rel="noopener">open full page ↗</a>
  </div>

  <script>
    // ————— three.js basics —————
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // AR button
    document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

    // lighting
    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(light);

    // reticle for placement
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ color: 0x00ffaa })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // state
    let xrRefSpace = null;
    let hitTestSource = null;
    let selecting = null; // 'grenade' | 'screen' | null
    let target = 'grenade'; // default

    // ————— grenade model —————
    const loader = new THREE.GLTFLoader();
    const grenadeRoot = new THREE.Group();
    grenadeRoot.visible = false;
    scene.add(grenadeRoot);

    loader.load(
      'assets/models/grenade.glb',
      (gltf) => {
        gltf.scene.traverse((o) => {
          if (o.isMesh) {
            o.castShadow = false;
            o.receiveShadow = false;
          }
        });
        // normalize size (roughly)
        const box = new THREE.Box3().setFromObject(gltf.scene);
        const size = new THREE.Vector3();
        box.getSize(size);
        const scale = 0.15 / Math.max(size.x, size.y, size.z); // target ~15cm max dimension
        gltf.scene.scale.setScalar(scale);
        gltf.scene.position.set(0, 0, 0);
        grenadeRoot.add(gltf.scene);
      },
      undefined,
      (err) => console.error('failed to load grenade.glb', err)
    );

    // ————— "web page" screen: a plane with a canvas texture —————
    const pageCanvas = document.createElement('canvas');
    pageCanvas.width = 640;
    pageCanvas.height = 1024;
    const pageCtx = pageCanvas.getContext('2d');

    // initial placeholder
    pageCtx.fillStyle = '#ffffff';
    pageCtx.fillRect(0,0,pageCanvas.width,pageCanvas.height);
    pageCtx.fillStyle = '#111';
    pageCtx.font = '28px system-ui';
    pageCtx.fillText('loading wikipedia…', 20, 50);

    const pageTexture = new THREE.CanvasTexture(pageCanvas);
    pageTexture.colorSpace = THREE.SRGBColorSpace;
    pageTexture.needsUpdate = true;

    // plane ~ 0.32m x 0.512m (portrait A6-ish)
    const screenWidthMeters = 0.32;
    const aspect = pageCanvas.width / pageCanvas.height; // ~0.625
    const screenHeightMeters = screenWidthMeters / aspect;

    const screenMat = new THREE.MeshBasicMaterial({ map: pageTexture, side: THREE.FrontSide, transparent: false });
    const screenGeo = new THREE.PlaneGeometry(screenWidthMeters, screenHeightMeters);
    const screenMesh = new THREE.Mesh(screenGeo, screenMat);
    screenMesh.visible = false;
    scene.add(screenMesh);

    // helpers: thin frame for tap targeting
    const screenFrame = new THREE.LineSegments(
      new THREE.EdgesGeometry(screenGeo),
      new THREE.LineBasicMaterial({ color: 0x00aaff })
    );
    screenMesh.add(screenFrame);

    // ————— fetch & rasterize wikipedia content —————
    const OFF = document.getElementById('offscreen');
    const WIKI_TITLE = 'Augmented_reality'; // url-encoded title segment

    async function loadWikipedia() {
      try {
        // mobile-html is cleaner and CORS-enabled
        const resp = await fetch(`https://en.m.wikipedia.org/api/rest_v1/page/mobile-html/${encodeURIComponent(WIKI_TITLE)}`, {
          headers: { 'accept': 'text/html' },
          mode: 'cors',
          cache: 'no-cache'
        });
        const html = await resp.text();
        OFF.innerHTML = html;

        // trim header cruft
        const hdr = OFF.querySelector('header');
        if (hdr) hdr.parentNode.removeChild(hdr);

        // basic styling for readability
        const style = document.createElement('style');
        style.textContent = `
          body { font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
          #content, .content, body { background:#fff; color:#111; }
          img, svg, video { max-width: 100% !important; height: auto !important; }
        `;
        OFF.prepend(style);

        await rasterize();
      } catch (e) {
        console.warn('wikipedia fetch/rasterize failed', e);
        pageCtx.fillStyle = '#f8d7da';
        pageCtx.fillRect(0,0,pageCanvas.width,pageCanvas.height);
        pageCtx.fillStyle = '#721c24';
        pageCtx.font = '24px system-ui';
        pageCtx.fillText('unable to render live page.', 20, 60);
        pageCtx.fillText('opening link will work ↗', 20, 100);
        pageTexture.needsUpdate = true;
      }
    }

    async function rasterize() {
      // draw OFF into canvas
      const canvas = await html2canvas(OFF, {
        backgroundColor: '#ffffff',
        scale: 1,
        useCORS: true,
        allowTaint: false,
        windowWidth: OFF.scrollWidth,
        windowHeight: OFF.scrollHeight
      });
      // copy with current scroll window
      const viewH = pageCanvas.height;
      // take a slice matching the offscreen scrollTop
      const ctx = pageCtx;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,pageCanvas.width,pageCanvas.height);
      ctx.drawImage(canvas, 0, OFF.scrollTop, pageCanvas.width, viewH, 0, 0, pageCanvas.width, viewH);
      pageTexture.needsUpdate = true;
    }

    // scroll controls (affect OFF, then rerender)
    const SCROLL_STEP = 480;
    async function scrollBy(delta) {
      OFF.scrollTop = Math.max(0, Math.min(OFF.scrollHeight - OFF.clientHeight, OFF.scrollTop + delta));
      await rasterize();
    }

    // kick off content load
    loadWikipedia();

    // ————— AR session + hit testing —————
    const controller = renderer.xr.getController(0);
    scene.add(controller);

    controller.addEventListener('selectstart', () => {
      // try picking: if near screen or grenade, start dragging that; else if reticle visible, place selected target
      const hit = pickNearest();
      if (hit) {
        selecting = hit;
      } else if (reticle.visible) {
        if (target === 'grenade') {
          grenadeRoot.position.setFromMatrixPosition(reticle.matrix);
          grenadeRoot.visible = true;
        } else {
          screenMesh.position.setFromMatrixPosition(reticle.matrix);
          // face camera a bit
          screenMesh.lookAt(camera.position.x, camera.position.y, camera.position.z);
          screenMesh.visible = true;
        }
      }
    });

    controller.addEventListener('selectend', () => {
      selecting = null;
    });

    function pickNearest() {
      // use simple distance-to-reticle heuristic
      if (!reticle.visible) return null;
      const retP = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
      let best = null;
      let bestD = Infinity;
      if (grenadeRoot.visible) {
        const p = grenadeRoot.getWorldPosition(new THREE.Vector3());
        const d = p.distanceTo(retP);
        if (d < bestD && d < 0.25) { best = 'grenade'; bestD = d; }
      }
      if (screenMesh.visible) {
        const p = screenMesh.getWorldPosition(new THREE.Vector3());
        const d = p.distanceTo(retP);
        if (d < bestD && d < 0.35) { best = 'screen'; bestD = d; }
      }
      return best;
    }

    renderer.xr.addEventListener('sessionstart', async () => {
      const session = renderer.xr.getSession();
      xrRefSpace = await session.requestReferenceSpace('local');
      const viewerSpace = await session.requestReferenceSpace('viewer');
      const hitTestSourceReq = await session.requestHitTestSource({ space: viewerSpace });
      hitTestSource = hitTestSourceReq;

      session.addEventListener('end', () => {
        hitTestSource = null;
        xrRefSpace = null;
      });
    });

    // per-frame
    renderer.setAnimationLoop((timestamp, frame) => {
      if (!frame) {
        renderer.render(scene, camera);
        return;
      }

      const session = renderer.xr.getSession();
      const refSpace = xrRefSpace;
      if (hitTestSource && refSpace) {
        const viewerPose = frame.getViewerPose(refSpace);
        const hitResults = frame.getHitTestResults(hitTestSource);
        if (hitResults.length > 0) {
          const hit = hitResults[0];
          const pose = hit.getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
          if (selecting) {
            const pos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            if (selecting === 'grenade') grenadeRoot.position.copy(pos);
            else if (selecting === 'screen') screenMesh.position.copy(pos);
          }
        } else {
          reticle.visible = false;
        }
      }

      renderer.render(scene, camera);
    });

    // ————— UI wiring —————
    const $ = (id) => document.getElementById(id);
    $('targetGrenade').onclick = () => { target = 'grenade'; $('targetGrenade').style.opacity = '1'; $('targetScreen').style.opacity = '.6'; };
    $('targetScreen').onclick = () => { target = 'screen'; $('targetGrenade').style.opacity = '.6'; $('targetScreen').style.opacity = '1'; };
    $('scaleUp').onclick = () => {
      if (target === 'grenade') grenadeRoot.scale.multiplyScalar(1.15);
      else screenMesh.scale.multiplyScalar(1.15);
    };
    $('scaleDown').onclick = () => {
      if (target === 'grenade') grenadeRoot.scale.multiplyScalar(1/1.15);
      else screenMesh.scale.multiplyScalar(1/1.15);
    };
    $('scrollUp').onclick = () => scrollBy(-SCROLL_STEP);
    $('scrollDown').onclick = () => scrollBy(SCROLL_STEP);

    // resize
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
